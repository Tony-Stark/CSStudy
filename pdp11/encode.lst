Technion Computer Science Department -- PDP/11 X-Assembler Version (5.5) AA.


	S O U R C E    F I L E    :    encode.s11
	=========================================

000000                             1     . = torg + 1000
001000   012746 000010             2     main: mov #010, -(sp)
001004   012746 001462             3     	  mov #Test1, -(sp)
001010   012746 001442             4           mov #Matrix, -(sp)
001014   004767 000002             5     	  jsr pc, decode
001020   000000                    6     	  halt
                                   7     
001022   010146                    8     decode: mov r1, -(sp)	;push r1 on stack 10
001024   010246                    9     	mov r2, -(sp)		;push r2 on stack 6
001026   010346                   10     	mov r3, -(sp)		;push r3 on stack 4
001030   010446                   11     	mov r4, -(sp)		;push r4 on stack 2
001032   010546                   12     	mov r5, -(sp)		;push r5 on stack 0
                                  13     	;tst -(sp) 			;allocate memory for isLegal result
                                  14     	;mov 14(sp), -(sp)	;push matrix on stack
                                  15     	;jsr pc, isLegal
                                  16     	;tst (sp)+			;check result
                                  17     	;beq decodeIllegal	;if illegal, save byte in output address unchanged
                                  18     	;tst (sp)+			;clear additional matrix address from stack
001034   016601 000014            19     	mov 14(sp), r1     	;r1 now has the address of the first key
001040   116604 000020            20     	movb 20(sp), r4		;the address of the first Text byte is stored in r4
001044   042704 177400            21     	bic #177400, r4
001050   110402                   22     	movb r4, r2			;move value of current Text byte to r2
001052   042702 177760            23     	bic #177760, r2		;store y value in r2
001056   110403                   24     	movb r4, r3 		;move value of current Text byte to r3
001060   042703 177417            25     	bic #177417, r3			;clear first 4 bits
001064   072327 177774            26     	ash #-4, r3			;store x value in r3
001070   000400                   27     	br deyfind
                                  28     	
                                  29     ;yfind finds the address of the key which equals to y
001072   112104                   30     deyfind:  movb (r1)+, r4		;first map key is stored in r4, and r1 is advanced by 1
001074   042704 177400            31     	bic #177400, r4
001100   020402                   32     	cmp r4, r2				;if y part is equal to the value of the key, continue
001102   001373                   33     	bne deyfind
001104   062701 177777            34     	add #-1, r1				;r1 is decremented to account for the previous incrementation 
001110   010104                   35     	mov r1, r4				;r4 stores the address of the y key
001112   016601 000014            36     	mov 14(sp), r1		;reset key pointer
                                  37     	
                                  38     ;dexfind finds the address of the key which equals to x
001116   112105                   39     dexfind:  movb (r1)+, r5		;first map key is stored in r5, and r1 is advanced by 1
001120   042705 177400            40     	bic #177400 ,r5
001124   020503                   41     	cmp r5, r3				;if x part is equal to the value of the key, continue
001126   001373                   42     	bne dexfind
001130   062701 177777            43     	add #-1, r1				;r1 is decremented to account for the previous incrementation
001134   010105                   44     	mov r1, r5 				;r5 stores address of x key
001136   016601 000014            45     	mov 14(sp), r1		;reset key pointer
                                  46     
                                  47     ;diff calculates the location of x, y
001142   166604 000014            48     dediff:   sub 14(sp), r4	;r4 now has the serial place of y in the key map
001146   166605 000014            49     	sub 14(sp), r5		;r5 now has the serial place of x in the key map
001152   010403                   50     	mov r4, r3				;r3 now has the serial place of y in the key map
001154   005002                   51     	clr r2					;r2 is cleared to enable division of r2, r3
001156   005004                   52     	clr r4					;r4 is cleared to enable division of r4, r5
001160   071227 000004            53     	div #4, r2				;r2 stores the row of y, r3 stores the column of y
001164   071427 000004            54     	div #4, r4				;r4 stores the row of x, r5 stores the column of x
001170   020204                   55     	cmp r2, r4			;if rows are equal, proceed to case A
001172   001403                   56     	beq dCaseA			
001174   020305                   57     	cmp r3, r5				;if columns are equal, proceed to case B
001176   001422                   58     	beq dCaseB
001200   000442                   59     	br deCaseC				;else, proceed to case C
                                  60     
001202   020327 000000            61     dCaseA:  cmp r3, #0		;if column of y is 3, it will be cleared in order to enable cyclic movement
001206   001410                   62     	beq dSubr3A
001210   020527 000000            63     	cmp r5, #0			;if column of x is 3, it will be cleared in order to enable cyclic movement
001214   001410                   64     	beq dSubr5A
001216   162703 000001            65     	sub #1, r3				;y is moved right in a cyclic order
001222   162705 000001            66     	sub #1, r5				;x is moved right in a cyclic order
001226   000441                   67     	br degetLower				;proceed to calculate value of W
001230   012703 000004            68     dSubr3A: mov #4, r3				;column of y is cleared to enable cyclic movement
001234   000762                   69     		br dCaseA
001236   012705 000004            70     dSubr5A: mov #4, r5				;column of x is cleared to enable cyclic movement
001242   000757                   71     		br dCaseA
                                  72     		
001244   020227 000000            73     dCaseB:  cmp r2, #0			;if row of y is 3, it will be cleared in order to enable cyclic movement
001250   001410                   74     	beq dSubr2B
001252   020427 000000            75     	cmp r4, #0				;if row of x is 3, it will be cleared in order to enable cyclic movement
001256   001410                   76     	beq dSubr4B
001260   162702 000001            77     	sub #1, r2				;y is moved down in a cyclic order
001264   162704 000001            78     	sub #1, r4				;x is moved down in a cyclic order
001270   000420                   79     	br degetLower				;proceed to calculate value of W
001272   012702 000004            80     dSubr2B: mov #4, r2				;row of y is cleared to enable cyclic movement
001276   000762                   81     		br dCaseB
001300   012704 000004            82     dSubr4B: mov #4, r4				;row of x is cleared to enable cyclic movement
001304   000757                   83     		br dCaseB
                                  84     		
001306   110301                   85     deCaseC: movb r3, r1
001310   042701 177400            86     	bic #177400, r1
                                  87     			;column of y is stored in a temp register
001314   110503                   88     	movb r5, r3	
001316   042703 177400            89     	bic #177400, r3
                                  90     	;column of y is changed to the column of x
001322   110105                   91     	movb r1, r5	
001324   042705 177400            92     	bic #177400, r5
                                  93     	;column of x is changed to the column of y
001330   000400                   94     	br degetLower				;proceed to calculate value of W
                                  95     
                                  96     ;gets lower 4 bits of output
001332   020227 000000            97     degetLower: cmp r2, #0		;if row of lower 4 bits is zero, the loop is finished
001336   001404                   98     	beq degetUpper
001340   062703 000004            99     	add #4, r3				;4 is added to the r3 register to get the place of the lower bits in the map
001344   077206                  100     	sob r2, degetLower
001346   000400                  101     	br degetUpper				;proceed to calculate upper 4 bits
                                 102     
                                 103     ;gets higher 4 bits of output
001350   020427 000000           104     degetUpper: cmp r4, #0		;if row of higher 4 bits is zero, the loop is finished
001354   001404                  105     	beq deFinal
001356   062705 000004           106     	add #4, r5				;4 is added to the r5 register to get the place of the higher bits in the map
001362   077406                  107     	sob r4, degetUpper
001364   000400                  108     	br deFinal				;the serial place of the lower 4 bits in the map is stored in r3, and that of the higher - in r5
                                 109     	
                                 110     ;calculates output byte and stores it in the output label
                                 111     ;checks if program has completed its operation
001366                           112     deFinal:
001366   066603 000014           113     	add 14(sp), r3		;the address of the first key is added to r3 to get the address of the value of lower 4 bits
001372   066605 000014           114     	add 14(sp), r5		;the address of the first key is added to r5 to get the address of the value of upper 4 bits
001376   111302                  115     	movb (r3), r2
001400   042702 177400           116     	bic #177400 ,r2
                                 117     	;r2 now stores value of lower 4 bits
001404   111504                  118     	movb (r5), r4	
001406   042704 177400           119     	bic #177400, r4
                                 120     	;r4 now stores value of higher 4 bits
001412   072427 000004           121     	ash #4, r4				;r4 is shifted 4 times to the left to enable addition of lower 4 bits
001416   060204                  122     	add r2, r4				;r4 now stores 8 bits: first the lower 4, and then the upper 4. This is the needed result.
001420   016601 000016           123     	mov 16(sp), r1			;address of first Output byte is added to r1
001424   110411                  124     	movb r4, (r1)	
                                 125     	;the encryption/decryption result is saved in the Output label 
001426   012605                  126     	mov (sp)+, r5
001430   012604                  127     	mov (sp)+, r4
001432   012603                  128     	mov (sp)+, r3
001434   012602                  129     	mov (sp)+, r2
001436   012601                  130     	mov (sp)+, r1
001440   000207                  131     	rts pc
                                 132     	
                                 133     	
001442      012    006    010    134     	Matrix: .byte 12, 6, 10, 15, 1, 16, 3, 7, 4, 14, 5, 11, 2, 13, 0, 17
            015    001    016            
            003    007    004            
            014    005    011            
            002    013    000            
            017                          
001462      000                  135     	Test1: .byte 0


	S Y M B O L   T A B L E
	=======================

SYMBOL    VALUE   TYPE
------    -----   ----
main      001000  text     
Test1     001462  text     
Matrix    001442  text     
decode    001022  text     
deyfind   001072  text     
dexfind   001116  text     
dediff    001142  text     
dCaseA    001202  text     
dCaseB    001244  text     
deCaseC   001306  text     
dSubr3A   001230  text     
dSubr5A   001236  text     
degetLow  001332  text     
dSubr2B   001272  text     
dSubr4B   001300  text     
degetUpp  001350  text     
deFinal   001366  text     
